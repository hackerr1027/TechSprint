
# Global model store (in production, use a database)
# Key: model_id, Value: InfrastructureModel
MODEL_STORE = {}


@app.post("/edit/diagram")
def edit_via_diagram(request: DiagramEditRequest):
    """
    Edit infrastructure via diagram events
    
    Flow: Diagram Edit → Model Update → Security Check → Regenerate Terraform
    
    Supported operations:
    - add_resource: Add new EC2, RDS, LB, subnet
    - remove_resource: Remove resource by ID
    - move_resource: Move EC2/RDS to different subnet
    - update_resource_property: Change instance type, storage, etc.
    
    Loop Prevention: Tracks EditSource.DIAGRAM, doesn't regenerate diagram events
    Security: All edits validated before applying
    """
    try:
        # Get current model from store (or use provided data)
        # In production, fetch from database by model_id
        current_model = MODEL_STORE.get(request.current_model_id)
        if not current_model:
            raise HTTPException(
                status_code=404,
                detail=f"Model {request.current_model_id} not found"
            )
        
        # Execute the edit operation
        result = None
        
        if request.operation == "add_resource":
            result = add_resource(
                current_model,
                request.resource_type,
                request.properties,
                EditSource.DIAGRAM
            )
        
        elif request.operation == "remove_resource":
            result = remove_resource(
                current_model,
                request.resource_id,
                EditSource.DIAGRAM
            )
        
        elif request.operation == "move_resource":
            result = move_resource(
                current_model,
                request.resource_id,
                request.target_subnet_id,
                EditSource.DIAGRAM
            )
        
        elif request.operation == "update_resource_property":
            result = update_resource_property(
                current_model,
                request.resource_id,
                request.property_name,
                request.value,
                EditSource.DIAGRAM
            )
        else:
            raise HTTPException(400, f"Unknown operation: {request.operation}")
        
        # Check result
        if not result.success:
            return {
                "success": False,
                "error": result.error,
                "warnings": [w.to_dict() for w in result.warnings] if result.warnings else []
            }
        
        # Store updated model
        updated_model = result.model
        MODEL_STORE[updated_model.model_id] = updated_model
        
        # Regenerate Terraform (diagram stays the same since edit came from diagram)
        terraform_code = generate_terraform_code(updated_model)
        
        # Generate security report
        security_report = generate_security_report(result.warnings)
        
        return {
            "success": True,
            "model_id": updated_model.model_id,
            "terraform_code": terraform_code,
            "security_warnings": [w.to_dict() for w in result.warnings],
            "security_report": security_report,
            "message": f"Applied {request.operation} successfully"
        }
    
    except Exception as e:
        raise HTTPException(500, f"Edit failed: {str(e)}")


@app.post("/edit/terraform")
def edit_via_terraform(request: TerraformEditRequest):
    """
    Edit infrastructure via Terraform code modifications
    
    Flow: Terraform Edit → Parse Changes → Model Update → Security Check → Regenerate Diagram
    
    Parse Strategy:
    1. Compare original vs modified Terraform
    2. Extract changes using infra_id metadata
    3. Convert to edit operations
    4. Apply to model
    5. Regenerate diagram
    
    Loop Prevention: Tracks EditSource.TERRAFORM, doesn't regenerate Terraform
    Security: Validates all changes before applying
    
    IMPORTANT: Only works with Terraform generated by this system
    """
    try:
        # Get current model
        current_model = MODEL_STORE.get(request.current_model_id)
        if not current_model:
            raise HTTPException(404, f"Model {request.current_model_id} not found")
        
        # Parse Terraform changes
        edit_operations = parse_terraform_edits(
            request.original_terraform,
            request.modified_terraform
        )
        
        if not edit_operations:
            return {
                "success": True,
                "message": "No changes detected",
                "model_id": current_model.model_id
            }
        
        # Apply each operation sequentially
        working_model = current_model
        all_warnings = []
        
        for op in edit_operations:
            operation_type = op['operation']
            
            if operation_type == 'update_resource_property':
                result = update_resource_property(
                    working_model,
                    op['resource_id'],
                    op['property'],
                    op['value'],
                    EditSource.TERRAFORM
                )
            elif operation_type == 'move_resource':
                result = move_resource(
                    working_model,
                    op['resource_id'],
                    op['target_subnet_id'],
                    EditSource.TERRAFORM
                )
            elif operation_type == 'remove_resource':
                result = remove_resource(
                    working_model,
                    op['resource_id'],
                    EditSource.TERRAFORM
                )
            else:
                continue  # Skip unknown operations
            
            if not result.success:
                return {
                    "success": False,
                    "error": f"Failed at {operation_type}: {result.error}",
                    "warnings": [w.to_dict() for w in result.warnings] if result.warnings else []
                }
            
            working_model = result.model
            all_warnings.extend(result.warnings)
        
        # Store updated model
        MODEL_STORE[working_model.model_id] = working_model
        
        # Regenerate diagram (Terraform stays the same since edit came from Terraform)
        mermaid_diagram = generate_mermaid_diagram(working_model)
        diagram_desc = generate_diagram_description(working_model)
        
        # Generate security report
        security_report = generate_security_report(all_warnings)
        
        return {
            "success": True,
            "model_id": working_model.model_id,
            "mermaid_diagram": mermaid_diagram,
            "description": diagram_desc,
            "security_warnings": [w.to_dict() for w in all_warnings],
            "security_report": security_report,
            "operations_applied": len(edit_operations),
            "message": f"Applied {len(edit_operations)} operation(s) from Terraform"
        }
    
    except Exception as e:
        raise HTTPException(500, f"Terraform edit failed: {str(e)}")
