"""
Terraform Parser Module
Parses Terraform code generated by THIS SYSTEM ONLY.

This is NOT a general Terraform parser. It only works with code we generated,
using embedded metadata comments to map resources back to the model.

Metadata Format:
  # infra_id: resource-id
  # editable: property_name

Parse Strategy:
1. Extract resources by infra_id comments
2. Parse only safe/editable fields
3. Ignore any unknown blocks
4. Convert to edit operations
"""

import re
from typing import Dict, List, Optional, Tuple
from .model import EditSource


class TerraformParseResult:
    """Result of parsing Terraform code"""
    def __init__(self, resource_updates: List[Dict], errors: List[str]):
        self.resource_updates = resource_updates
        self.errors = errors
    
    def has_changes(self) -> bool:
        return len(self.resource_updates) > 0


def extract_resource_blocks(terraform_code: str) -> List[Dict]:
    """
    Extract resource blocks with metadata from Terraform code
    
    Returns list of resources with their infra_id and parsed properties
    """
    resources = []
    
    # Split into lines for parsing
    lines = terraform_code.split('\n')
    
    current_resource = None
    current_infra_id = None
    in_resource_block = False
    brace_depth = 0
    
    for i, line in enumerate(lines):
        # Check for metadata comment
        infra_id_match = re.match(r'#\s*infra_id:\s*(\S+)', line.strip())
        if infra_id_match:
            current_infra_id = infra_id_match.group(1)
            continue
        
        # Check for resource block start
        resource_match = re.match(r'resource\s+"([^"]+)"\s+"([^"]+)"\s*{', line.strip())
        if resource_match and current_infra_id:
            resource_type = resource_match.group(1)
            resource_name = resource_match.group(2)
            
            current_resource = {
                'infra_id': current_infra_id,
                'terraform_type': resource_type,
                'terraform_name': resource_name,
                'properties': {},
                'start_line': i
            }
            in_resource_block = True
            brace_depth = 1
            current_infra_id = None  # Reset for next resource
            continue
        
        # Count braces to track block depth
        if in_resource_block:
            brace_depth += line.count('{')
            brace_depth -= line.count('}')
            
            # Parse properties (simple key = value)
            prop_match = re.match(r'\s*(\w+)\s*=\s*(.+)', line.strip())
            if prop_match:
                key = prop_match.group(1)
                value_str = prop_match.group(2).rstrip(',').strip()
                
                # Parse value (remove quotes, handle basic types)
                if value_str.startswith('"') and value_str.endswith('"'):
                    value = value_str[1:-1]
                elif value_str.isdigit():
                    value = int(value_str)
                else:
                    value = value_str
                
                current_resource['properties'][key] = value
            
            # End of resource block
            if brace_depth == 0:
                resources.append(current_resource)
                current_resource = None
                in_resource_block = False
    
    return resources


def map_terraform_to_model_type(terraform_type: str) -> Optional[str]:
    """Map Terraform resource type to our model resource type"""
    mapping = {
        'aws_instance': 'ec2',
        'aws_db_instance': 'rds',
        'aws_lb': 'load_balancer',
        'aws_subnet': 'subnet'
    }
    return mapping.get(terraform_type)


def extract_edits_from_terraform(original_code: str, modified_code: str) -> TerraformParseResult:
    """
    Compare original and modified Terraform to extract edit operations
    
    Returns:
        TerraformParseResult with list of resource updates
    """
    original_resources = extract_resource_blocks(original_code)
    modified_resources = extract_resource_blocks(modified_code)
    
    # Build lookup by infra_id
    original_by_id = {r['infra_id']: r for r in original_resources}
    modified_by_id = {r['infra_id']: r for r in modified_resources}
    
    resource_updates = []
    errors = []
    
    # Detect changes
    for infra_id, modified in modified_by_id.items():
        if infra_id not in original_by_id:
            # New resource (not supported in edit mode, only via add_resource)
            continue
        
        original = original_by_id[infra_id]
        
        # Compare editable properties
        model_type = map_terraform_to_model_type(modified['terraform_type'])
        if not model_type:
            continue
        
        # Define editable fields per resource type
        EDITABLE_FIELDS = {
            'ec2': {
                'instance_type': 'instance_type',
                'subnet_id': 'subnet_id'
            },
            'rds': {
                'instance_class': 'instance_class',
                'allocated_storage': 'allocated_storage'
            },
            'load_balancer': {}
        }
        
        editable = EDITABLE_FIELDS.get(model_type, {})
        
        for tf_field, model_field in editable.items():
            original_value = original['properties'].get(tf_field)
            modified_value = modified['properties'].get(tf_field)
            
            if original_value != modified_value and modified_value is not None:
                # Detect subnet move vs property update
                if tf_field == 'subnet_id':
                    # Parse terraform reference (e.g., "aws_subnet.subnet_private_1.id")
                    subnet_match = re.search(r'aws_subnet\.(\w+)\.id', str(modified_value))
                    if subnet_match:
                        # Convert terraform name back to infra_id
                        # terraform name format: subnet_private_1 -> subnet-private-1
                        subnet_tf_name = subnet_match.group(1)
                        subnet_id = subnet_tf_name.replace('_', '-')
                        
                        resource_updates.append({
                            'operation': 'move_resource',
                            'resource_id': infra_id,
                            'target_subnet_id': subnet_id
                        })
                else:
                    # Regular property update
                    resource_updates.append({
                        'operation': 'update_resource_property',
                        'resource_id': infra_id,
                        'property': model_field,
                        'value': modified_value
                    })
    
    # Detect removed resources
    for infra_id in original_by_id:
        if infra_id not in modified_by_id:
            resource_updates.append({
                'operation': 'remove_resource',
                'resource_id': infra_id
            })
    
    return TerraformParseResult(resource_updates, errors)


def parse_terraform_edits(original_terraform: str, modified_terraform: str) -> List[Dict]:
    """
    High-level function to parse Terraform edits into edit operations
    
    Returns list of edit operation dictionaries ready for edits.py
    """
    result = extract_edits_from_terraform(original_terraform, modified_terraform)
    
    if result.errors:
        # Log errors but continue with what we could parse
        print(f"Terraform parse warnings: {result.errors}")
    
    return result.resource_updates
